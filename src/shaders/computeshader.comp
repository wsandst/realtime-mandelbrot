#version 430 core

#ifdef GL_ES
precision highp float;
#endif

//Output texture
layout(binding = 0, rgba32f) uniform writeonly image2D framebuffer;
uniform sampler1D colormap;

uniform float viewX = -2.25; //X: -2.25 to 0.75. Y: -1.5 to 1.5
uniform float viewWidth = 3;
uniform float viewY = -1.5;
uniform float viewHeight = 3;

uniform int ITERATIONS = 50;
uniform int COLOR_ITER_LOOP = 10;

vec3 startColor = vec3(1.0, 0.2, 0.2);
vec3 endColor = vec3(0.2, 0.2, 1.0);

#define M_PI 3.1415926535897932384626433832795
#define M_LOG2 0.69314

vec3 getColorCircle(float i)
{
    vec3 color;
    color.z = (sin(i / 10 + 2 * M_PI / 3) + 1) / 2;
    color.x = (sin(i / 10 + 4 * M_PI / 3) + 1) / 2;
    color.y = (sin(i / 10) + 1) / 2;
    return color;
}

vec3 mandelbrot(vec2 pos)
{
  float u = 0.0;
  float v= 0.0;
  float u2 = u * u;
  float v2 = v*v;
  float x = viewX + pos.x * viewWidth;
  float y = viewY + pos.y * viewHeight;
  /* iterate the point */
  int i = 0;
  for (i = 0; i < ITERATIONS && ((u2 + v2) < 16.0); i++) {
        v = 2 * u * v + y;
        u = u2 - v2 + x;
        u2 = u * u;
        v2 = v * v;
  };

  if (i >= ITERATIONS) { //Interior
    return vec3(0.0, 0.0, 0.0);
  }
  else { //Exterior
    //float color = 1 - float(i) / ITERATIONS;
    float smoothI = i + 1 - log(log(sqrt(u2 + v2))) / M_LOG2;
    return texture(colormap, fract(sqrt(smoothI) / COLOR_ITER_LOOP)).rgb;
  };
}

//Return a color based on the current float pos or integer pixel pos
vec4 draw(vec2 pos, ivec2 pixel)
{
  return vec4(mandelbrot(pos), 1.0);//vec4(pos.x, 0.0, pos.y, 1.0);
}

layout (local_size_x = 16, local_size_y = 8) in;
void main(void) {
  ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
  ivec2 size = imageSize(framebuffer);
  if (pix.x >= size.x || pix.y >= size.y) {
    return;
  }
  vec2 pos = vec2(pix) / vec2(size.x - 1, size.y - 1);
  vec4 color = vec4(pos.x, 0.0, pos.y, 1.0);
  imageStore(framebuffer, pix, draw(pos, pix));
}
